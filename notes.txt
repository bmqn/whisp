----------------------------------------------------
Notes on sematics
----------------------------------------------------

<@a : x> = <@a> . a<x>
x, y, z : f = [x] . [y] . [z] . f

----------------------------------------------------

<a> . [0]a

<!a> binds a as a const location
<@a> binds a as a mutable location

<!a> . [0]a is not a valid program

but

<@a> . [0]a is a valid program

<!a{N}> binds a as const location but calls N with a promoted to mutable for scope

<!a{['H']a . ['e']a . ['l']a . ['l']a . ['o']a}>

or with some literal sugar

<!a{"Hello"a}>

or with a mutable location a

<@a{"Hello"a}> . ", World!"a

----------------------------------------------------

x : T
a : #T
N : U

Does a<x> . a<x> : T# -> T make sense ?
Not on it's own, I think that
a<x> . a<x> . N : T# -> (T -> U)

       a<x> . N :  T -> U
<@a> . a<x> . N : T# -> T -> U
<@a : x>    . N : T# -> U

----------------------------------------------------

x : Char
s : Char#

f      : Int -> Int
f_     : Int
strlen : Char# -> Int

f      = <x> . s(0 -> [x], [#s] . [x + 1] . f)
f_     = [0] . f
strlen = <@s> . f_

----------------------------------------------------

Const locations, which means abstractions read instead of pop
You cannot push to a const location

f      : Int -> Int
f_     : Int
strlen : ~Char# -> Int

f      = <x> . s++(0 -> [x], [#s] . [x + 1] . f)
f_     = [0] . f
strlen = <~@s> . f_

If s : ~T#, then

s<...> or s(...) will bind the value at s, but not pop it
s++<...> or s++(...) will bind the value at s, move the ptr forward, but not pop it

Not sure how we'd track this though.
What stores this ptr that gets incremented?
Can they interact with eachother? i.e. pop, then read, then pop etc.

I think a better solution is to encode a location offset, somehow?

s!5<...> will bind the value at 5 cells back from the start
s!l<...> will bind the value at l cells back from the start

----------------------------------------------------

s : Char#
x : Char

f      : Nil
print  : Char# -> Nil

f      = s(x : 0 -> *, [x]out . f)
print  = <@s> . f

s(x : ...) pops from s and binds in x for use in cases

----------------------------------------------------

s : Char#
x : Char

f      : Nil
print  : ~Char# -> Nil

f      = s++(x : 0 -> *, [x]out . f)
print  = <~@s> . f

s++(x : ...) reads from , moves the ptr forward, and binds in x for use in cases

----------------------------------------------------
Notes on pattern matching
----------------------------------------------------

nil = [<_> . <x> . [x]];
cons = [<h> . <t> . <f> . [t] . [h] . f];
head = <l> . [nil] . [<h> . <t> . [h]] . l;
list = [[nil] . [1] . cons] . [2] . cons;

The matching looks like
[[nil] . [1] . cons] . [2] . cons

head cons . [h] . [t] = [h];
head nil = [nil];

----------------------------------------------------

Define type str

str : loc -> u64

A string is a loc that points to data, and a u64 length.

strlen : str -> u64
strlen : (loc -> u64) -> u64
strlen = <@p> . <l> . [l]

str . strlen : u64

Define function print

print : str -> nil
print : (loc -> u64) -> nil
print = <@p> . l{0 -> *, p<x> . [x]out . [l] . [-1] . + . [#p] . [-1] . + . print}

